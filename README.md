# Documento de ingeniería / Red Machine 

Este repositorio contiene todos los materiales necesarios para crear a "pompo", el robot autonomo creado por el equipo "Red Machine", con el objetivo de participar en la categoría de Futuros Ingenieros en las diferentes etapas de la WRO Venezuela, en su edición 2025. 

![Image](https://github.com/user-attachments/assets/86d8b3ba-9f00-4d94-9a0b-7fb3f87d222e)


# Contenido

 -  [Miembros del equipo Red Machine](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Miembros-de-Red-Machine)
 -  [Introduccion](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Introducción)
 -  [Diseño mecánico](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Diseño-mecánico)
 -  [Diseño del software](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Diseño-del-software)
 -  [Videos del funcionamiento de pompo](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Videos-del-funcionamiento-de-pompo)
 -  [Historia y cronología](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Historia-y-cronología)


# Miembros de Red Machine
-Samuel Jose Galban Franco

-Juan Diego Cano Barros

-Angel Saul Rodriguez Guerra

![red machine 2024](https://github.com/RoboticaLLR/redmachine2024/assets/146040533/d5bb5fc0-b1bd-47a8-9ac3-c190587ae5ae)

   
# Introducción
El equipo ha hecho su mayor esfuerzo para conseguir construir el mejor robot posible. Nuestra preparación para estas olimpiadas se ha basado en un largo aprendizaje en construcción, diseño y programación, y la experiencia de competencias anteriores ha sido fundamental. Largas horas de análisis y estudio de la pista ha llevado a la creación de una estrategia propia, basada en los componentes con los que el equipo deseó trabajar, y esperando conseguir la mejor participación posible en las diversas etapas de esta competencia. 
# Etapas del desarrollo

LUKA 
During the 2023 season, the design of the robot was always one of the biggest problems the team faced, this during all phases of the competition. The acrylic bases that were used in the first competitions did not work, since they had many imperfections, causing the traction and steering system to be poorly located, as well as a really bad distribution. Despite all this, that chassis gave us an idea of ​​how to design a new one, so after the 2023 national competition, new acrylic bases were used, this time laser cutted. After this, the chassis looked really good in all aspects.

![bases de acrilico pequeño](https://github.com/RoboticaLLR/RedMachine/assets/146040533/1ab2bf5b-492d-4d9f-b8cb-7154f9053f9f)

In addition, the robot's wheels were changed with new ones that held better to the steering system, which also provided better aesthetics to the robot.

After participating in the World Cup in Panama, the team decided to make important changes when creating the new prototype. 
Among these changes, the closer between the wheels of the traction and steering system stands out, with the aim of increasing the turning radius, allowing tighter turns. This mainly helps the development of the obstacle challenge, due to the difficulty of the challenge, and the strategy the team wishes to use.

![Luka`s right](https://github.com/user-attachments/assets/7adb4b68-6ba3-44b4-b7dc-02d3c609dd1a)
   
![julian de lado 2024 2](https://github.com/RoboticaLLR/redmachine2024/assets/146040533/c3f7801c-d940-4992-b78f-98beb0f70ac8)  


Likewise, the size of the robot was reduced by approximately 5 centimeters, helping the robot to be freer on the playing field, and making it easier to meet the challenges. To achieve this, the acrylics were redesigned, with the new ones having a completely different structure from the previous one.
![acrilicos luka pequeño1](https://github.com/RoboticaLLR/redmachine2024/assets/146040533/93bda588-5d18-4f1c-8973-c6c9f80af70f)

Another very important change was to redesign the steering system, which was again built with Lego pieces, coming from the spike prime robotics kit number 45678. 3 of these pieces were joined with a pair of wheels to finish its construction.

![foto sistema direccion  1](https://github.com/user-attachments/assets/fb4946ed-f055-4171-9542-48f1bef775e9)



In the same way, a 3D design was made, where we could see and efficiently analyze everything related to the robot.
### right
![WhatsApp Image 2024-11-13 at 13 52 58_05e5de05](https://github.com/user-attachments/assets/0b5c060e-33ad-4477-b3c4-377615a6cf7b)
### Left
![WhatsApp Image 2024-11-13 at 13 54 51_21982268](https://github.com/user-attachments/assets/3b6c59b8-5937-493e-82a6-7f05f8257ca6)
### Front
![WhatsApp Image 2024-11-13 at 13 53 22_d6ef839f](https://github.com/user-attachments/assets/0f04d1ab-3092-4d91-9025-a2c85ab1c4a4)
### Back
![WhatsApp Image 2024-11-13 at 13 52 30_cd6ade6e](https://github.com/user-attachments/assets/e959fc69-fd42-4a32-8b51-ee0cc8c62794)
### Above
![WhatsApp Image 2024-11-13 at 13 55 55_4ce29d41](https://github.com/user-attachments/assets/279e3c23-2072-4bb1-bf15-aab938d821c9)
### Below
![WhatsApp Image 2024-11-13 at 13 56 54_399b5e24](https://github.com/user-attachments/assets/ee7c4b06-4de3-42b4-be29-2a76cc698b72)

# Videos version 2.0 robot
 - [First challenge (ALL POSIBILITIES)](https://www.youtube.com/watch?v=auAgh7E2WA8)

[![image](https://github.com/user-attachments/assets/ed1c0d5b-dab7-4e8b-98aa-dfcefc9b1e91)](https://www.youtube.com/watch?v=auAgh7E2WA8)
 

 - [Second challenge practice](https://www.youtube.com/watch?v=cjjnRDXaDAU)

[![image](https://github.com/user-attachments/assets/b4dc474c-5cb7-4fe4-aece-13e8c19d635f)](https://www.youtube.com/watch?v=cjjnRDXaDAU)


# Analysis of engines operation
In the following space, aspects of the operation of the 2 motors of our robot will be shown.

## Motor Core Hex 

![image](https://github.com/RoboticaLLR/redmachine2024/assets/155327813/6b746939-ccca-4912-8b1c-9ad4e71ff221)

- Pinout: The Core Hex motor uses a 2-pin JST-VH connector for motor power.

![i](https://github.com/user-attachments/assets/cb5b1293-0dfd-4212-b587-674aa33f21d3)

- Weight: 7 ounces

- Installation: To use this motor in the way the equipment needs it, a 5mm hexagonal shaft is used, from which one end emerges from each side of the motor. Said shaft has a length of 11.8cm, and its structure is made of stainless steel. At each end of this axle, a traction wheel was placed, whose diameter is 90mm. Finally these wheels were secured to the axle with collars, which have a set screw that tightens towards the axle.

![image](https://github.com/user-attachments/assets/8bef9bab-571f-4ab2-a236-f04a72f93711)

![image](https://github.com/user-attachments/assets/e6822eb6-4ea4-480e-8bea-89c9130ea8c0)

![image](https://github.com/user-attachments/assets/d6850397-0bf1-4e28-895d-833c83149a95)

![image](https://github.com/RoboticaLLR/redmachine2024/assets/155327813/980cb8f4-5084-4b9c-bd1e-64fec1b01462)

![image](https://github.com/RoboticaLLR/redmachine2024/assets/155327813/a078144d-4553-4803-a540-ab6f2e750554)

- Power: The motor power is specified below. 

- Torque: 3.2 N-m

- Operating voltage: 12V

- Free speed: 125 RPM


## Smart Robot Servo

![Screenshot 2024-11-08 103745](https://github.com/user-attachments/assets/473534ce-37d2-4f08-9721-a207be8490b3)


- Installation: A cut aluminum double servo arm was anchored to the Smart Robot Servo. Then a screw was placed in one of the entrances of the aluminum arm, which joined it with two pieces of Lego. A second screw joins the two Lego pieces mentioned above.  Likewise, two screws from the chassis were anchored in the third piece of Lego, so that it worked as a support. Finally the wheels were placed, which fit between the three Lego pieces.

![Screenshot 2024-11-08 103852](https://github.com/user-attachments/assets/43367d50-6ccf-498b-9c06-c9612c199d0e)


![foto sistema direccion 2](https://github.com/user-attachments/assets/d22ed9c8-2579-46ad-96a0-f00472432b56)


![foto sistema direccion  1](https://github.com/user-attachments/assets/fb4946ed-f055-4171-9542-48f1bef775e9)



- Operating voltage: From 4.8V to 7.4V. On the robot, the servo runs on 5V. 

- Turning radius: Can rotate up to 270°

- Torque: 13.5 kg-cm

- Speed: 0.13s/60º

- Weight: 2.05 ounces

- Gear material: Brass

- Power: The servo power is specified below. 

- Input pulse:    
Minimum-500 μs        
Center-1500μs       
Maximum-2500 μs

![Screenshot 2024-11-08 104017](https://github.com/user-attachments/assets/26bf1371-24b6-427f-be1d-9da5c48c0dc1)




# Sensors
Next, the specifications of the sensors that are in Luka will be shown.

## Ultrasounds
Three ultrasounds are used to define the distance between the robot and the walls of the track, specifically the side and front walls according to the direction in which Luka is heading.

![Screenshot 2024-11-08 104130](https://github.com/user-attachments/assets/1e2dcd67-23b4-4e43-9aa0-8c34c85a97e9)

- Connection pins:        
VCC            
Trig (Ultrasound Trigger)                 
Echo (Ultrasound reception)             
GND

![image](https://github.com/RoboticaLLR/redmachine2024/assets/146040533/9cfeae57-2def-47ad-9158-ded9577fc56a)


- Supply voltage: 5V

- Working frequency: 40 KHz

- Maximum detection range: 450cm

- Minimum detection range: 2cm

- Detection angle: 15 degrees

- Consumption current: 15mA



## giroscope
A BNO055 is used to measure the degrees of every turn and know when the robot should stop turning. The giroscope is used both to avoid the traffic signs and to take the turns. 

![BNO055](https://github.com/user-attachments/assets/33946a22-2ff8-4f12-b0c4-97331cfa95cb)

- Connection pins:    
Vin           
3V      
P50       
GND         
PS1          
SDA         
INT          
SCL  
ADR      
RST 

The team use the Vin input to power the sensor, the ground pin, and the SDA and SCL to stablish a communication between the arduino and the BNO055. 

Data Output:
The BNO055 can output the following sensor data:

- Absolute Orientation (Euler Vector, 100Hz): Three axis orientation data based on a 360° sphere

- Absolute Orientation (Quaterion, 100Hz): Four point quaternion output for more accurate data manipulation

- Angular Velocity Vector (100Hz): Three axis of 'rotation speed' in rad/s

- Acceleration Vector (100Hz): Three axis of acceleration (gravity + linear motion) in m/s^2

- Magnetic Field Strength Vector (20Hz): Three axis of magnetic field sensing in micro Tesla (uT)

- Linear Acceleration Vector (100Hz): Three axis of linear acceleration data (acceleration minus gravity) in m/s^2

- Gravity Vector (100Hz): Three axis of gravitational acceleration (minus any movement) in m/s^2

 

# Camera
Luka uses one camera to detect the color of the traffic signs. This is the pixy2. 

![pixy2.1](https://github.com/user-attachments/assets/46298b4d-2184-4b40-9b81-577219ed9214)

The pixy2 works at 60 fps, and is able to detect objects, lines and colors. On luka the main objetive of the camera is to detect colors (red and green). 
its connected to the arduino with an IDC 2 ICSP Arduino cable that goes into the arduino ICSP pins, wich provides all the connections needed to power and communicate with the pixy. 

# Controller boards
Luka uses a single controller boards: an Arduino Mega 2560. The Arduino, which is in charge of controlling the actuators, the sensors, and the entire movement of the robot.

## Arduino mega 2560

![Screenshot 2024-11-08 104239](https://github.com/user-attachments/assets/877f86c1-f333-4b46-bc66-869465ee6ebf)
  

- Power: 9V

- Pins used: 21

- Maximum current per pin: 40 mA

- Flash memory: 256 KB

- SRAM: 8KB

- Weight: 37 grams

- Consumption: 93 mA




# Robot power
In Luka there are two individual powering systems.

## 12V ciruit
This circuit use 3 batteries, each one contain 4v approximately. The 3 batteries are connected on series, so the voltage adds up. The H-bridge is the electrical component that recieve this energy, and use it to power two ultrasounds and the traction motor. 
To connect the batteries the team use two packs of two batteries each, but one of them is moded so it only uses one battery. 

![pack de baterias modeado 2](https://github.com/user-attachments/assets/c07fb25c-0ca6-4173-b0fa-797ddf2f16f2)
![2 packs de baterias 4V 4](https://github.com/user-attachments/assets/7a6248cc-fc05-4bf4-bfd4-aad78766bb06)


## 9V circuit
This circuit use 3 9V batteries connected on parallel, so the amperage adds up, keeping the same 9V. Its connected directly to the arduino board, wich power one ultrasound, the pixy cam and the servo motor. Each one of this components are energized by a 5V output pin of the arduino. 

![Primera foto 9 voltios 2](https://github.com/user-attachments/assets/79c1b298-762f-4a96-95a9-bb6aa8bb3e1f)
![segunda foto 9 voltios 2](https://github.com/user-attachments/assets/a10426e9-767d-496e-b5a6-bf88363a8a4a)

# Conexions diagram
The connection diagram is shown so that the entire circuit can be clearly seen.

![Diagrama de conexion luka nuevo](https://github.com/user-attachments/assets/6a02a72f-8d6e-445f-9afe-fa92380ca7a5)





## Codigo de la version 2.0 del robot

# Image Processing
To process the image, Luka uses one camera. This is the pixy2. 

![pixy2.1](https://github.com/user-attachments/assets/46298b4d-2184-4b40-9b81-577219ed9214)

The pixy2 works at 60 fps, and is able to detect objects, lines and colors. On luka the main objetive of the camera is to detect colors (red and green). 
its connected to the arduino with an IDC 2 ICSP Arduino cable that goes into the arduino ICSP pins, wich provides all the connections needed to power and communicate with the pixy. 

## Color detection
Pixy2 uses a color-based filtering algorithm to detect objects called the Color Connected Components (CCC) algorithm. Pixy2 calculates the color (hue) and saturation of each RGB pixel from the image sensor and uses these as the primary filtering parameters. The hue of an object remains largely unchanged with changes in lighting and exposure. Pixy2's CCC algorithm remembers up to 7 different color signatures.

After a color is saved on a color signature, the pixy will add it to a table of objects that it is currently tracking and assign it a tracking index. It will then attempt to find the object (and every object in the table) in the next frame by finding its best match. Each tracked object receives an index between 0 and 255 that it will keep until it either leaves Pixy2's field of view. 

![color_tracking](https://github.com/user-attachments/assets/46d2f0c5-c726-4a08-a899-b9a19b0e1dee)


## Programming 
To set the colors that the camera should detect, the team uses pixymon. PixyMon is an application that runs on Windows, MacOs and Linux. It allows you to see what Pixy2 sees, either as raw or processed video. It also allows you to configure your Pixy2, set the output port and manage color signatures. PixyMon communicates with Pixy2 over a standard mini USB cable.

![Screenshot 2024-11-11 103435](https://github.com/user-attachments/assets/f58a573e-7a54-49de-9017-4953aa863677)

On pixymon the team set 6 signatures, three for green and three for red. Signatures 1, 3 and 5 for red, and signatures 2, 4 and 6 for green. 

After this the arduino proccesing needed to be done. 

On the arduino, the team uses the pixy2 library, which allows to obtain all the information needed from the pixy detection. Then, using the following code, the team saves when the pixy detects a color and which signatures does the color correspond to on a variable called "hola". If hola is divisible by two, then the color is green, and if hola isn't dividible by two, then the color is red. 

- [Pixy code](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/Pixy.ino)


# General function of robot

## Servo Determination

The servo motor is set to pin 2 of the arduino, where it is configured using the `pro.attach(2)` command and can also be moved using the `pro.write()` command used throughout the code.


## Orientation
With the ultrasound sensors we detect where the walls are and when we reach a curve we define whether it is necessary to cross to the right or to the left (stored as 1=counterclockwise, 2=clockwise), saving us problems with the lines of the floor. This can be made because the car crashes with the wall, allowing us to know when he is on a sideturn. This part of the code occurs when the program begins.

    if((d<50)&&(d!=0)&&(a==0)){
    if((di<80)&&(d!=0)){ // Definicion giro horario
    a=2;
    pro.write(derecha);
    Serial.println("a2");
    Serial.println(d);
    delay(1800);
    pro.write(rec);

    giro++;
    analogWrite(2,vel);
    Serial.println("a2");
    delay(500);
    }

    if((di>80)||(di==0)){ // Definicion giro antihorario
    a=1;
    pro.write(izquierda);
    Serial.println("a1");
    Serial.println(d);
    delay(1400);
    giro++;
    pro.write(rec);

     analogWrite(2,vel);
    Serial.println("a1");
     }
     d=sensor_2.ping_cm();
     delay(500);
}

## Gyroscope Sideturns

The gyroscope is essencial on the sideturns part, we use a gy-97 BNO055 and a the Euler Angles to get a combination from both magnetometer and acelerometer included on the sensor, this way we get precise angles, without any drifting that any acelerometer has. 

How we implemented in the code was in order for 6 functions. There are Girarizq90, Girarder90, iraizq, irader, iraizq2, irader2. These functions are intended to make both 90 degrees sideturns, and return to the way its supposed the robot to face. These works by establishing a variable "angulof" that works as the expected angle. Then a loop is responsible to check if it its near to that angle and declared as a correct orientation.

All this functions can be seen on 
- [Gyroscope Functions](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/GyroscopeFunctions)

# First Challenge


## Correction

Even though Gyroscope give us a precise angle, sometimes we can face diferent problems because of the robots, or walls implemented on the Challenge. Thats why we created a pretty simple rectification system that prevents Luka crashing against the Walls.

This Correction works by the 2 ultrasonic sensor on both sides of the robot. When the distance between the robot and the wall is small, we make a short movement either to the  left or to the right to avoid the Challenge to end.The code we use is the next one:

    if (((dd<15)&&(dd>0)&&(giro!=0)&&(d>100))||((dd<15)&&(dd>0)&&(giro!=0)&&(d==0))){
    pro.write(izquierda);
    delay(300);
    pro.write(rec);
    delay(300);
    }
     if (((di<15)&&(di>0)&&(giro!=0)&&(d>80))||((di<15)&&(di>0)&&(giro!=0)&&(d==0))){
    pro.write(derecha);
     delay(300);
     pro.write(rec);
      delay(300)
        }

This part of the code can also be found on 
- [Correction](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Correction.ino)

## First Challenge parking


Every time we do a side turn, we increment in 1 the variable giros, once we detected this variable is equal to 11 we can me sure its the final track, so we just turn in 90 degrees and go forward 3 seconds.

    if(giro>11){
    di=sensor_1.ping_cm();
    dd=sensor_3.ping_cm();
    d=sensor_2.ping_cm();
     delay(3000);
     
    digitalWrite(adelante,LOW);
    analogWrite(2,0);
        }

# Obstacle Challenge



##  Detection of Pillars
Once it receives the information from the pixycam, it can move to the left or right depending on the cone it has detected. We use a simple algorithm to detect which is the biggest traffic sign, this way it doesnt gets affected with any other red or green sign on the enviroment

```
int numBlocks = pixy.ccc.getBlocks();

  if (numBlocks > 0) {
    int maxArea = 0; // Variable para almacenar el área máxima
    int maxSignature = 0; // Variable para almacenar la firma del bloque con mayor área

    // Buscar el bloque con el área más grande
    for (int i = 0; i < numBlocks; i++) {
      int area = pixy.ccc.blocks[i].m_height * pixy.ccc.blocks[i].m_width;
      if (area > maxArea) {
        maxArea = area;
        maxSignature = pixy.ccc.blocks[i].m_signature; // Guardar la firma del bloque más grande
      }
    }

    // Evaluar la firma del bloque con mayor área
    if (maxSignature % 2 == 0 && maxSignature != 0) {
      Serial.println("verde");
      hola = 2; // Asignar 1 a la variable hola
      Serial.println(hola);
    } 
    else if (maxSignature % 2 == 1) {
      Serial.print("rojo");

      hola = 1; // Asignar 2 a la variable hola
       Serial.println(hola);
    }
  }

```
It can also be seen at
- [Pillar Detection](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Pillar-Detection.ino)

> [!IMPORTANT]
> It can still be affected by other objects if theres any pillars or havent detected anything.

> [!IMPORTANT]
> This algorithm has been asigned to the function "detectarconos" and repeats each iteration




## Movement through Orientation

Once we detect the direction and are aware of the lane we are in, we make a pre-programed movement, this way we only programmed 6 possible sideturns for the first lap.  They may change by the lane, orientation and spot of the track.

    After every sideturn each variable such as cono1 and cono2 and carril are reestablished to zero and we add 1 to "giros" and "vuelta". All posible sideturns are located at "Sideturns first lap" link.


- [Sideturns first lap](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Sideturns-First-Lap.ino)

## Pillar Avoidment First Lap


The main strategy to avoid crashing against the pillars is knowing where the robot is. Thats why we implemented the easiest way we could think and thats by establishing 3 lanes(middle, left and right). This way we only need to worry about the movement between these lanes, and not to exactly calculate the distance between pilars.

How the robot avoids the pillars is by avoiding one or two maximum pillars. This way we only prepared 2 sideturns for the first pillar (red or green) and then 2 sideturns for the second pillar (left to right and right to left). This change of lane is very easy with the implementation of an Gyroscope.



> [!TIP]
>   Movement is made by "esquivarconos" and the storage of the pillars is by "contarconos"

- [Esquivarconos](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Esquivarconos.ino)
- [Contarconos](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Contarconos.ino)

## Post-first sideturn

The robot detects and evade every pillar using the same strategy, this time it has already storaged the orientation and beacuse of our sideturn strategy it always begins at the middle of the track, this way we also know the lane we are.

    At the last part of the path the robots reduces all its moves due to the posibility to crash against the parking lot 
> [!TIP]This part of the code uses the functions "cruzar" and "esquivarconos"

- [Cruzar](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Cruzar.ino)
- [Esquivarconos](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Esquivarconos.ino)

## Pillar storage


Every time we detect a pillar we store them on a group of variables depending on the part of the track it is and if its the second or the first pillar it detects. Thats why after the first lap we dont have any need to use the camera or to make very long sideturns
> [!TIP] The way we separated is: The first number means the part of the track, the second number means if it either goes first or second on the track. Example Cono12 (first lane, second pillar)

# Second and Third Lap Strategy



## Next Pillar

A very important part for the Second and Third lap Strategy is the first pillar on the next part of the track. We use the function "proxicono" to detect it

It works by defining it what part of the track the robot is, and finding the next code with the variables that store them. You can also check the function at:

- [Proxicono](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Proxicono.ino)

## Sideturns


Once we completed the first lap, the Sideturns only require the Gyroscope and one ultrasonic sensor. We calculate the distance with the wall perpendicular against us, we use the "proxicono" function to know what are we supposed to avoid. This way depending on the side we have to go and the orientation it makes a shorter or larger path to avoid it.



> [!IMPORTANT]
> If this change its not made, the robot would not be able to complete the obstacle challenge in 3 minutes.

> [!TIP]
> This part of the code is defined on the funcion "giroscompleta"


> [!NOTE]
> This  simple change saves us around 30 seconds per lap, this way we get enough time to make the entire challenge4
- [Sideturns Post First Lap](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Sideturns-Post-First-Lap.ino)

## Parking Obstacle Challenge

As we know the robot will always be on an exact lane, we can assume it will never detect with the ultrasonic sensor a pillar, thats why the parking strategy only includes the ultrasonic sensor and the Gyroscope

    if(giro==12&&d<120){
    delay(800);
    pro.write(derecha);
    girarder90();
    pro.write(rec);
    delay(3000);
    digitalWrite(2,0);
    delay(10000000);
    }

- [Parking Obstacle Challenge](https://github.com/RoboticaLLR/redmachine2024/blob/main/src/functions/Parking-Obstacle-Challenge.ino)


> [!IMPORTANT]
> El codigo del segundo reto se basa en los mismos principios que el codigo utilizado hasta este momento,





# Diseño mecánico
"Pompo" es un robot autónomo diseñado con piezas de lego, con la finalidad de conseguir la mayor presición y estabilidad posible durante las rondas de competencia. Dichas piezas fueron extraídas de un kit lego spike prime código 45678 y spike prime expansion set código 45681. 
El fundamento que llevó a utilizar piezas de lego para el cuerpo de pompo se basa en la conocida eficiencia de los robots construidos de dicha manera, tomando en cuenta los resultados positivos y la facilidad que permiten a la hora de la construcción. 
Además, en el apartado "v-photos" se muestran fotos del diseño de Pompo, donde se pueden ver y analizar eficientemente todos los componentes, piezas y estructuras.
A continuación el diseño 3D de las diversas bases de lego que se usan en la estructura (en el apartado "models" se ve el archivo original del diseño): 

![Image](https://github.com/user-attachments/assets/5b7af0b6-441f-4880-8d1f-e71637f6b006)

![Image](https://github.com/user-attachments/assets/a4c70eec-a4b5-4d26-86e3-5d2190d3b326)

![Image](https://github.com/user-attachments/assets/dd3a7d52-695a-4912-9071-1e9b083b1505)



## Componentes electrónicos 
A pesar de que la construcción del robot fue hecha con piezas de lego, para todo el apartado electrónico el equipo se decidió por utilizar piezas externas con las que ya se han familiarizado. Entre estas se encuentran los siguientes sensores y actuadores:


Arduino Mega 2560: Es una placa microcontroladora basada en el ATmega2560. Tiene 54 pines de entrada/salida digital y 16 entradas analógicas, un oscilador de cristal de 16 MHz, una conexión USB, una toma de alimentación, una cabecera ICSP y un botón reset. El arduino es la placa que contiene el código para el funcionamiento de pompo, encargándose de analizar toda la información obtenida por los sensores para así lograr cumplir con el reto. 

![mega 2560](https://github.com/user-attachments/assets/edc71e77-3581-48eb-af96-6dfae65660ac)


Puente-H: Es un tipo de controlador que permite cambiar la polaridad de un motor de corriente continua, hacia delante y hacia atrás, además de ser la fuente de energía de diversos sensores. El modelo de puente H utilizado es el L298N, que nos permite cambiar la velocidad de los motores en función de la tensión enviada por el Arduino.

![puente H pequeño](https://github.com/RoboticaLLR/RedMachine/assets/146040533/264757f2-118f-42c9-9dd8-2a3c91455834)

Sensor de ultrasonido: Es un sensor que utiliza sonidos ultrasónicos para detectar el tiempo de rebote del sonido de un lado a otro. Utilizando el Arduino Mega 2560 se determina la distancia en base al tiempo que tarda la onda en volver, teniendo así este sensor la función de determinar cuando hay una pared cerca para así realizar el giro correspondiente.
El modelo utilizado de este sensor es el HC-sr04.

![HC-sr04](https://github.com/user-attachments/assets/a59b0102-8994-4ac4-aa06-3d6553ae1a2d)

Giroscopio: Es un sensor que mide la orientación del robot en grados. Se utiliza para poder realizar giros precisos, principalmente con la función de los giros para cambio de sección (giros de 90°), y mantener el robot con un movimiento en línea recta. 
El modelo utilizado de este sensor es 

![BNO055](https://github.com/user-attachments/assets/02c487ce-d624-411f-9db3-a2a3ef82a514)

Pixy 2.1: Es una cámara que tiene guardados valores que corresponden a los colores rgb de las señales de tráfico. Para detectar, la cámara busca esos valores en los píxeles de la imagen y, cuando se detecta un número exacto de pixeles de alguno de los colores anexados, pixy envía los datos al arduino, el cual se encarga luego de realizar los movimientos precisos para evitar los semáforos. 

![pixy2 1 2](https://github.com/user-attachments/assets/6397d5c9-d6fe-4c80-a7b9-d097bee0ba3e)


Servo motor de Rev Robotics: Es un motor eléctrico con sensor de retroalimentación de posición integrado, que permite realizar movimientos angulares perfectos, utilizando una señal que va de 0V a 5V, donde cada valor que pueda tener el voltaje representa un ángulo exacto, cumpliendo con excelencia la función de realizar los giros.

![servo pequeño](https://github.com/RoboticaLLR/RedMachine/assets/146040533/57aaa91d-b5e5-4360-aef2-06025d15f8b0)

Motor lego ev3: Dispositivo que convierte la energía eléctrica en movimiento mecánico, permitiendo en este caso mover una caja de cambios y movilizar las ruedas. La velocidad y el par que tiene vienen determinados por la tensión enviada a través del puente en H, siendo moderados por el Arduino.

![Image](https://github.com/user-attachments/assets/05c10969-e9a6-404b-a141-5e44218d54df)

Raspberry pi 5: Es la última versión de las computadoras de placa única desarrolladas por la Fundación Raspberry Pi, lanzada en 2023. Esta versión incluye un procesador Broadcom BCM2712 de cuatro núcleos Arm Cortex-A76 a 2,4 GHz, lo que la hace entre dos y tres veces más rápida que la generación anterior. Viene en versiones de 4 GB y 8 GB de memoria RAM LPDDR4X, incorpora una GPU mejorada compatible con OpenGL ES 3.1 y Vulkan 1.2, y permite conectar dos monitores 4K a 60 Hz al mismo tiempo. Además, ofrece conectividad avanzada con Wi-Fi 5, Bluetooth 5.0, Ethernet Gigabit, dos puertos USB 3.0, dos USB 2.0, dos micro HDMI, ranura microSD de alta velocidad, conectores MIPI para cámaras y pantallas, y un puerto PCIe para discos SSD u otros periféricos rápidos (usando un adaptador). También cuenta con un botón de encendido, reloj en tiempo real, soporte para ventilador y mejoras en la gestión de energía. Gracias a estas características, la Raspberry Pi 5 es ideal tanto para proyectos de electrónica y robótica como para usarse como mini PC, servidor, centro multimedia o incluso para tareas más exigentes como inteligencia artificial y procesamiento de imágenes, representando un gran avance en potencia y versatilidad dentro del mundo de las computadoras compactas y económicas.

![Image](https://github.com/user-attachments/assets/33d23ad4-043a-4c6b-8bab-c31a648c3e4a)

Sensor LiDAR: Un sensor LiDAR (Light Detection and Ranging) es un dispositivo de teledetección que utiliza pulsos de luz láser para medir distancias con gran precisión y crear mapas tridimensionales del entorno. Su funcionamiento se basa en emitir miles de pulsos de láser por segundo hacia los objetos; estos pulsos rebotan y regresan al sensor, que mide el tiempo que tarda cada pulso en ir y volver. Como la velocidad de la luz es conocida, este tiempo de vuelo permite calcular la distancia exacta entre el sensor y los objetos o superficies. Los datos recolectados se procesan para formar una nube de puntos, que es una representación 3D detallada del área escaneada.

![Image](https://github.com/user-attachments/assets/234ebb64-bf87-4ec4-82ca-5e8cac3d7af3)

En este momento la raspberry y el sensor LiDAR estan incluidos en la estructura del robot, sin embargo no se utilizan para la realización del reto.

El Arduino está alimentado por una batería de 9v, y enciende mediante un interruptor. Se encarga de alimentar y dar las respectivas señales al servomotor, para que sea capaz de realizar los cruces de forma efectiva con facilidad al giroscopio, además de dar y recibir señales del resto de sensores. 

Por último, el puente H está conectado y alimentado por dos baterías de 3,7v y se enciende con el mismo interruptor que enciende el Arduino.
El puente H recibe señales del Arduino que llevan a mover el motor en diferentes direcciones y velocidades. También se encarga de alimentar los sensores ultrasónicos.
  

# Diseño del software

1. Análisis de imágenes
-  [Procesamiento de imágenes](https://github.com/Samu4035/REDMACHINE-2025/blob/main/src/software.md#Procesamiento-de-imágenes)
-  [Detección de color](https://github.com/Samu4035/REDMACHINE-2025/blob/main/src/software.md#Detección-de-color)
-  [Programación](https://github.com/Samu4035/REDMACHINE-2025/blob/main/src/software.md#Programación)



# Videos del funcionamiento de pompo
 - [FUTUROS INGENIEROS-Reto 1](https://youtu.be/I5WXGXlZpG4?si=D2IsjQdoafDccQmA)

[![Image](https://github.com/user-attachments/assets/3a998c08-fef1-4247-a1c7-fdddfd4fdfc8)](https://youtu.be/I5WXGXlZpG4?si=D2IsjQdoafDccQmA)
 

- [FUTUROS INGENIEROS-Reto 2](https://youtu.be/XvPb05R_A2o?si=kEyuvRi_PKU7EDct)

[![Image](https://github.com/user-attachments/assets/7d8d684a-25f8-4bad-a824-62b761711ac8)](https://youtu.be/XvPb05R_A2o?si=kEyuvRi_PKU7EDct)


# Índice mecánico
Para más información sobre la mecánica, se ha creado un documento en el que puedes consultar las especificaciones de las piezas y mecanismos del robot.

- [Motores](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Análisis-del-funcionamiento-de-los-motores)
- [Sensores](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Sensores)
- [Camera](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Cámara)
- [Placas controladora](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Placas-controladoras)
- [Alimentación del robot](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Alimentación-del-robot)



# Historia y cronología del equipo

1. Temporada 2023
- [Julio 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Julio-2023)
- [Agosto 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Agosto-2023)
- [Septiembre 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Septiembre-2023)
- [Octubre 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Octubre-2023)
2. Temporada 2024 
- [Febrero 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Febrero-2024)
- [Marzo 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Marzo-2024)
- [Abril 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Abril-2024)
- [Mayo 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Mayo-2024)
- [Junio 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Junio-2024)
- [Octubre 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Octubre-2024)
- [Noviembre 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Noviembre-2024)
3. Temporada 2025
- [Febrero 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Febrero-2025)
- [Marzo 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Marzo-2025)
- [Abril 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Abril-2025)
- [Mayo 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Mayo-2025)
4. Julian, Luka y Pompo
- [JULIAN 1.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-1.0)
- [JULIAN 2.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-2.0)
- [JULIAN 3.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-3.0)
- [JULIAN 4.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-4.0)
- [JULIAN 5.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-5.0)
- [LUKA 1.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#LUKA-1.0)

- [LUKA 2.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md)

- [LUKA 3.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#LUKA-3.0)

- [POMPO 1.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#POMPO-1.0)

- [POMPO 2.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#POMPO-2.0)

- [POMPO 3.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#POMPO-3.0)





