# Documento de ingeniería / Red Machine 

Este repositorio contiene todos los materiales necesarios para crear a "pompo", el robot autonomo creado por el equipo "Red Machine", con el objetivo de participar en la categoría de Futuros Ingenieros en las diferentes etapas de la WRO Venezuela, en su edición 2025. 

![Image](https://github.com/user-attachments/assets/86d8b3ba-9f00-4d94-9a0b-7fb3f87d222e)


# Contenido

 -  [Miembros del equipo Red Machine](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Miembros-de-Red-Machine)
 -  [Introduccion](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Introducción)
 -  [Diseño mecánico](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Diseño-mecánico)
 -  [Diseño del software](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Diseño-del-software)
 -  [Videos del funcionamiento de pompo](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Videos-del-funcionamiento-de-pompo)
 -  [Historia y cronología](https://github.com/Samu4035/REDMACHINE-2025/blob/main/README.md#Historia-y-cronología)


# Miembros de Red Machine
-Samuel Jose Galban Franco

-Juan Diego Cano Barros

-Angel Saul Rodriguez Guerra

![red machine 2024](https://github.com/RoboticaLLR/redmachine2024/assets/146040533/d5bb5fc0-b1bd-47a8-9ac3-c190587ae5ae)

   
# Introducción
El equipo ha hecho su mayor esfuerzo para conseguir construir el mejor robot posible. Nuestra preparación para estas olimpiadas se ha basado en un largo aprendizaje en construcción, diseño y programación, y la experiencia de competencias anteriores ha sido fundamental. Largas horas de análisis y estudio de la pista ha llevado a la creación de una estrategia propia, basada en los componentes con los que el equipo deseó trabajar, y esperando conseguir la mejor participación posible en las diversas etapas de esta competencia. 
# Etapas del desarrollo

LUKA  
Durante la temporada 2023, el diseño del robot siempre fue uno de los mayores problemas que enfrentó el equipo, esto durante todas las fases de la competencia. Las bases de acrílico que se usaron en las primeras competencias no funcionaron, ya que tenían muchas imperfecciones, causando que el sistema de tracción y dirección estuviera mal ubicado, así como una distribución realmente mala. A pesar de todo esto, ese chasis nos dio una idea de cómo diseñar uno nuevo, por lo que después de la competencia nacional 2023, se usaron nuevas bases de acrílico, esta vez cortadas con láser. Después de esto, el chasis se veía realmente bien en todos los aspectos.  
![bases de acrilico pequeño](https://github.com/RoboticaLLR/RedMachine cambiadas por otras nuevas que se sujetaban mejor al sistema de dirección, lo que también proporcionó mejor estética al robot.  
Después de participar en la Copa Mundial en Panamá, el equipo decidió hacer cambios importantes al crear el nuevo prototipo.  
Entre estos cambios destaca el acercamiento entre las ruedas del sistema de tracción y dirección, con el objetivo de aumentar el radio de giro, permitiendo giros más cerrados. Esto principalmente ayuda al desarrollo del desafío de obstáculos, debido a la dificultad del reto y a la estrategia que el equipo desea usar.  
  
![julian de lado 2024 2](https://github.com/RoboticaLLR/redmachinejo aproximadamente 5 centímetros, ayudando a que el robot tuviera mayor libertad en el campo de juego, y facilitando el cumplimiento de los retos. Para lograr esto, se rediseñaron los acrílicos, con los nuevos teniendo una estructura completamente diferente a la anterior.  
![acrilicos luka pequeño1](https://github.com/RoboticaLLR/redmachineñar el sistema de dirección, el cual nuevamente se construyó con piezas Lego, provenientes del kit de robótica Spike Prime número 45678. 3 de estas piezas fueron unidas con un par de ruedas para terminar su construcción.  
  
De la misma forma, se hizo un diseño 3D, donde pudimos ver y analizar eficientemente todo lo relacionado con el robot.  

  
# Videos versión 2.0 del robot  
 - [Primer desafío (TODAS LAS POSIBILIDADES)](https://www.youtube.com/watch?v=auAgh7E2WA8)  
[](https://www.youtube.com/watch?v=auAhttps://www.youtube.com/watch?v=cjjnRDXaDAU)  
[](https://www.youtube.com/watch?v=cjjnores  
A continuación, se mostrarán aspectos sobre el funcionamiento de los 2 motores de nuestro robot.  
## Motor Core Hex  
![image](https://github.com/RoboticaLLR/redmachineector JST-VH de 2 pines para la alimentación del motor.  
  
- Peso: 7 onzas  
- Instalación: Para usar este motor de la manera que el equipo lo necesita, se usa un eje hexagonal de 5 mm, del cual un extremo sobresale de cada lado del motor. Dicho eje tiene una longitud de 11.8 cm, y su estructura está hecha de acero inoxidable. En cada extremo de este eje, se colocó una rueda de tracción, cuyo diámetro es de 90 mm. Finalmente, estas ruedas fueron aseguradas al eje con collares, que cuentan con un tornillo de fijación que aprieta hacia el eje.  
  
  
  
![image](https://github.com/RoboticaLLR/redmachineine especifica a continuación.  
- Torque: 3.2 N-m  
- Voltaje de operación: 12V  
- Velocidad libre: 125 RPM  
## Servo Inteligente para Robots (Smart Robot Servo)  
  
- Instalación: Un brazo servo doble de aluminio recortado fue anclado al Smart Robot Servo. Luego, se colocó un tornillo en una de las entradas del brazo de aluminio, que lo une con dos piezas de Lego. Un segundo tornillo une las dos piezas de Lego mencionadas. Asimismo, dos tornillos del chasis fueron anclados en la tercera pieza de Lego, para que funcionara como soporte. Finalmente, se colocaron las ruedas, que encajan entre las tres piezas de Lego.  
  
  
  
- Voltaje de operación: De 4.8V a 7.4V. En el robot, el servo funciona a 5V.  
- Radio de giro: Puede girar hasta 270°  
- Torque: 13.5 kg-cm  
- Velocidad: 0.13s/60º  
- Peso: 2.05 onzas  
- Material de engranajes: Latón  
- Potencia: La potencia del servo se especifica a continuación.  
- Pulso de entrada:  
  Mínimo-500 μs  
  Centro-1500 μs  
  Máximo-2500 μs  
  
# Sensores  
A continuación, se muestran las especificaciones de los sensores que tiene Luka.  
## Ultrasonido  
Se usan tres ultrasónicos para definir la distancia entre el robot y las paredes de la pista, específicamente las paredes laterales y frontales según la dirección en la que Luka se esté moviendo.  
  
- Pines de conexión:  
  VCC  
  Trig (Disparo ultrasonido)  
  Echo (Recepción ultrasonido)  
  GND  
![image](https://github.com/RoboticaLLR/redmachine trabajo: 40 KHz  
- Rango máximo de detección: 450 cm  
- Rango mínimo de detección: 2 cm  
- Ángulo de detección: 15 grados  
- Corriente de consumo: 15 mA  
## Giroscopio  
Se usa un BNO055 para medir los grados de cada giro y saber cuándo el robot debe parar de girar. El giroscopio se usa tanto para evitar las señales de tránsito como para tomar las curvas.  
  
- Pines de conexión:  
  Vin  
  3V  
  P50  
  GND  
  PS1  
  SDA  
  INT  
  SCL  
  ADR  
  RST  
El equipo utiliza la entrada Vin para alimentar el sensor, el pin de tierra, y los pines SDA y SCL para establecer comunicación entre el Arduino y el BNO055.  
Salida de datos:  
El BNO055 puede entregar los siguientes datos de sensores:  
- Orientación absoluta (Vector Euler, 100Hz): Datos de orientación en tres ejes basados en una esfera de 360°  
- Orientación absoluta (Cuaternión, 100Hz): Salida cuaternión de cuatro puntos para manipulación más precisa  
- Vector de velocidad angular (100Hz): Tres ejes de ‘velocidad de rotación‘ en rad/s  
- Vector de aceleración (100Hz): Tres ejes de aceleración (gravedad + movimiento lineal) en m/s²  
- Vector de intensidad del campo magnético (20Hz): Tres ejes de detección del campo magnético en micro Tesla (uT)  
- Vector de aceleración lineal (100Hz): Tres ejes de aceleración lineal (aceleración menos la gravedad) en m/s²  
- Vector de gravedad (100Hz): Tres ejes de aceleración gravitacional (menos cualquier movimiento) en m/s²  
# Cámara  
Luka usa una cámara para detectar el color de las señales de tránsito. Esta es la pixy2.  
  
La pixy2 funciona a 60 fps, y es capaz de detectar objetos, líneas y colores. En Luka, el objetivo principal de la cámara es detectar colores (rojo y verde).  
Está conectada al Arduino con un cable IDC 2 ICSP Arduino que va a los pines ICSP del Arduino, lo cual proporciona todas las conexiones necesarias para alimentar y comunicarse con la pixy.  
# Placas controladoras  
Luka usa una sola placa controladora: un Arduino Mega 2560. El Arduino está a cargo de controlar los actuadores, los sensores y todo el movimiento del robot.  
## Arduino Mega 2560  
  
- Potencia: 9V  
- Pines usados: 21  
- Corriente máxima por pin: 40 mA  
- Memoria Flash: 256 KB  
- SRAM: 8 KB  
- Peso: 37 gramos  
- Consumo: 93 mA  
# Alimentación del robot  
En Luka hay dos sistemas individuales de alimentación.  
## Circuito de 12V  
Este circuito usa 3 baterías, cada una con aproximadamente 4V. Las 3 baterías están conectadas en serie, por lo que el voltaje se suma. El puente H es el componente eléctrico que recibe esta energía y la usa para alimentar dos sensores ultrasónicos y el motor de tracción.  
Para conectar las baterías el equipo utiliza dos paquetes de dos baterías cada uno, pero uno de ellos está modificado para usar sólo una batería.  
  
  
## Circuito de 9V  
Este circuito usa 3 baterías de 9V conectadas en paralelo, por lo que la amperaje se suma manteniendo los 9V. Está conectado directamente a la placa Arduino, que alimenta un ultrasonido, la cámara pixy y el servo motor. Cada uno de estos componentes es energizado por un pin de salida de 5V del Arduino.  
  
  
# Diagrama de conexiones  
Se muestra el diagrama de conexiones para que todo el circuito pueda verse claramente.  
  
## Código de la versión 2.0 del robot  
# Procesamiento de imágenes  
Para procesar la imagen, Luka usa una cámara. Esta es la pixy2.  
  
La pixy2 funciona a 60 fps, y es capaz de detectar objetos, líneas y colores. En Luka, el objetivo principal de la cámara es detectar colores (rojo y verde).  
Está conectada al Arduino con un cable IDC 2 ICSP Arduino que va a los pines ICSP del Arduino, lo que proporciona todas las conexiones necesarias para alimentar y comunicarse con la pixy.  
## Detección de color  
Pixy2 usa un algoritmo de filtrado basado en colores para detectar objetos llamado Color Connected Components (CCC). Pixy2 calcula el color (matiz) y saturación de cada píxel RGB del sensor de imagen y los usa como los parámetros principales de filtrado. El matiz de un objeto permanece mayormente inalterado con cambios en la iluminación y exposición. El algoritmo CCC de Pixy2 recuerda hasta 7 firmas de color diferentes.  
Después de que un color es guardado como una firma de color, la pixy lo añadirá a una tabla de objetos que está siguiendo actualmente y le asignará un índice de seguimiento. Luego intentará encontrar el objeto (y cada objeto en la tabla) en el siguiente cuadro buscando su mejor coincidencia. Cada objeto rastreado recibe un índice entre 0 y 255 que conservará hasta que deje el campo de visión de Pixy2.  
  
## Programación  
Para configurar los colores que la cámara debe detectar, el equipo usa PixyMon. PixyMon es una aplicación que corre en Windows, MacOs y Linux. Permite ver lo que Pixy2 ve, ya sea vídeo en crudo o procesado. También permite configurar Pixy2, establecer el puerto de salida y administrar firmas de color. PixyMon se comunica con Pixy2 mediante un cable USB mini estándar.  
  
En PixyMon, el equipo configura 6 firmas, tres para verde y tres para rojo. Las firmas 1, 3 y 5 para rojo, y las firmas 2, 4 y 6 para verde.  
Luego se realiza el procesamiento en Arduino.  
En Arduino, el equipo usa la librería pixy2, que permite obtener toda la información necesaria de la detección por pixy. Posteriormente, usando el siguiente código, el equipo guarda cuándo pixy detecta un color y a qué firma corresponde en una variable llamada "hola". Si "hola" es divisible por dos, entonces el color es verde, y si no es divisible por dos, entonces el color es rojo.  
  
# Función general del robot  
## Determinación del servo  
El servo motor está asignado al pin 2 del Arduino, donde se configura usando el comando `pro.attach(2)` y también puede moverse con el comando `pro.write()`, usado a lo largo del código.  
## Orientación  
Con los sensores ultrasónicos se detecta dónde están las paredes y, cuando se llega a una curva, se define si es necesario cruzar a la derecha o a la izquierda (guardado como 1=antihorario, 2=horario), evitándonos problemas con las líneas del suelo. Esto se puede hacer porque el carro choca con la pared, permitiendo saber cuándo está tomando un giro lateral. Esta parte del código ocurre al iniciar el programa.  
```cpp  
if((d<50)&&(d!=0)&&(a==0)){  
  if((di<80)&&(d!=0)){ // Definición giro horario  
    a=2;  
    pro.write(derecha);  
    Serial.println("a2");  
    Serial.println(d);  
    delay(1800);  
    pro.write(rec);  
    giro++;  
    analogWrite(2,vel);  
    Serial.println("a2");  
    delay(500);  
  }  
  if((di>80)||(di==0)){ // Definición giro antihorario  
    a=1;  
    pro.write(izquierda);  
    Serial.println("a1");  
    Serial.println(d);  
    delay(1400);  
    giro++;  
    pro.write(rec);  
    analogWrite(2,vel);  
    Serial.println("a1");  
  }  
  d=sensor_2.ping_cm();  
  delay(500);  
}  
```
## Giroscopio para giros laterales  
El giroscopio es esencial en la parte de giros laterales, usamos un BNO055 y los ángulos Euler para obtener una combinación del magnetómetro y acelerómetro incluidos en el sensor, así obtenemos ángulos precisos, sin ningún drift que pueda tener un acelerómetro.  
Cómo se implementó en el código es mediante 6 funciones. Están Girarizq90, Girarder90, iraizq, irader, iraizq2, irader2. Estas funciones están destinadas a hacer giros laterales de 90 grados y regresar a la orientación correcta que debería tener el robot. Funcionan estableciendo una variable "angulof" que sirve como el ángulo esperado. Luego un ciclo revisa si el robot está cerca de ese ángulo y lo declara como una orientación correcta.  
Todas estas funciones pueden verse en  

# Primer desafío  
## Corrección  
Aunque el Giroscopio nos da un ángulo preciso, a veces podemos enfrentar diferentes problemas debido a los robots o paredes implementadas en el Desafío. Por eso creamos un sistema de rectificación bastante simple que previene que Luka choque contra las paredes.  
Esta corrección funciona mediante los 2 sensores ultrasónicos en ambos lados del robot. Cuando la distancia entre el robot y la pared es pequeña, hacemos un movimiento corto hacia la izquierda o derecha para evitar que el desafío termine.  
El código que usamos es el siguiente:  
```cpp  
if (((dd<15)&&(dd>0)&&(giro!=0)&&(d>100))||((dd<15)&&(dd>0)&&(giro!=0)&&(d==0))){  
  pro.write(izquierda);  
  delay(300);  
  pro.write(rec);  
  delay(300);  
}  
if (((di<15)&&(di>0)&&(giro!=0)&&(d>80))||((di<15)&&(di>0)&&(giro!=0)&&(d==0))){  
  pro.write(derecha);  
  delay(300);  
  pro.write(rec);  
  delay(300);  
}  
```
Esta parte del código también puede encontrarse en  

## Estacionamiento del primer desafío  
Cada vez que hacemos un giro lateral, incrementamos en 1 la variable giros; una vez que detectamos que esta variable es igual a 11 podemos estar seguros de que es la pista final, así que simplemente giramos 90 grados y avanzamos durante 3 segundos.  
```cpp  
if(giro>11){  
  di=sensor_1.ping_cm();  
  dd=sensor_3.ping_cm();  
  d=sensor_2.ping_cm();  
  delay(3000);  
     
  digitalWrite(adelante,LOW);  
  analogWrite(2,0);  
}  
```
# Desafío de obstáculos  
## Detección de pilares  
Una vez recibe la información de la cámara pixy, puede moverse hacia la izquierda o derecha dependiendo del cono que haya detectado. Usamos un algoritmo simple para detectar cuál es la señal de tránsito más grande, de esta manera no se ve afectado por ninguna otra señal roja o verde en el entorno.  
```cpp  
int numBlocks = pixy.ccc.getBlocks();  
if (numBlocks > 0) {  
  int maxArea = 0; // Variable para almacenar el área máxima  
  int maxSignature = 0; // Variable para almacenar la firma del bloque con mayor área  
  // Buscar el bloque con el área más grande  
  for (int i = 0; i < numBlocks; i++) {  
    int area = pixy.ccc.blocks[i].m_height * pixy.ccc.blocks[i].m_width;  
    if (area > maxArea) {  
      maxArea = area;  
      maxSignature = pixy.ccc.blocks[i].m_signature; // Guardar la firma del bloque más grande  
    }  
  }  
  // Evaluar la firma del bloque con mayor área  
  if (maxSignature % 2 == 0 && maxSignature != 0) {  
    Serial.println("verde");  
    hola = 2; // Asignar 2 a la variable hola  
    Serial.println(hola);  
  }   
  else if (maxSignature % 2 == 1) {  
    Serial.print("rojo");  
    hola = 1; // Asignar 1 a la variable hola  
    Serial.println(hola);  
  }  
}  
```
También puede verse en  

> [!IMPORTANTE]  
> Aún puede verse afectado por otros objetos si hay pilares o no ha detectado nada.  
> [!IMPORTANTE]  
> Este algoritmo está asignado a la función "detectarconos" y se repite en cada iteración.  
## Movimiento mediante orientación  
Una vez detectamos la dirección y sabemos en qué carril estamos, hacemos un movimiento preprogramado; así sólo programamos 6 posibles giros laterales para la primera vuelta. Estos pueden cambiar según el carril, la orientación y la ubicación en la pista.  
Después de cada giro lateral, variables como cono1, cono2 y carril se restablecen a cero y se añade 1 a "giros" y "vuelta". Todos los giros posibles se encuentran en el enlace "Sideturns first lap".  

## Evitación de pilares en la primera vuelta  
La estrategia principal para evitar chocar contra los pilares es saber dónde está el robot. Por eso implementamos la forma más sencilla que pudimos imaginar: estableciendo 3 carriles (centro, izquierda y derecha). Así sólo hay que preocuparse por el movimiento entre estos carriles, y no calcular exactamente la distancia entre pilares.  
Cómo el robot evita los pilares es evitando uno o dos como máximo. Por eso sólo preparamos 2 giros laterales para el primer pilar (rojo o verde) y luego 2 giros laterales para el segundo pilar (de izquierda a derecha y de derecha a izquierda). Este cambio de carril es muy sencillo con la implementación de un Giroscopio.  
> [!CONSEJO]  
> Movimiento está implementado en "esquivarconos" y el almacenamiento de los pilares está en "contarconos"  
 
## Después del primer giro lateral  
El robot detecta y evade cada pilar usando la misma estrategia, esta vez ya ha almacenado la orientación y, debido a nuestra estrategia de giros laterales, siempre inicia en el centro de la pista, así también sabemos en qué carril está.  
En la parte final del recorrido, el robot reduce todos sus movimientos debido a la posibilidad de chocar contra el estacionamiento.  
> [!CONSEJO] Esta parte del código usa las funciones "cruzar" y "esquivarconos"  

## Almacenamiento de pilares  
Cada vez que detectamos un pilar lo almacenamos en un grupo de variables dependiendo de la parte de la pista en la que está y si es el primero o segundo pilar que detecta. Por eso, después de la primera vuelta no necesitamos usar la cámara ni hacer giros laterales muy largos.  
> [!CONSEJO] La forma en que lo separamos es: El primer número indica la parte de la pista, el segundo número indica si es el primer o segundo pilar en la pista. Ejemplo: Cono12 (primer carril, segundo pilar)  
# Estrategia para la segunda y tercera vuelta  
## Próximo pilar  
Una parte muy importante para la estrategia de la segunda y tercera vuelta es el primer pilar en la siguiente parte de la pista. Usamos la función "proxicono" para detectarlo.  
Funciona definiendo en qué parte de la pista está el robot y buscando el siguiente código con las variables que almacenan los pilares. También puedes ver la función en:  
 
## Giros laterales  
Una vez completada la primera vuelta, los giros laterales sólo requieren el Giroscopio y un sensor ultrasónico. Calculamos la distancia con la pared perpendicular a nosotros, usamos la función "proxicono" para saber qué pilar debemos evitar. Así, dependiendo del lado al que tengamos que ir y la orientación, hace un camino más corto o largo para evitarlo.  
> [!IMPORTANTE]  
> Si este cambio no se hace, el robot no podrá completar el desafío de obstáculos en 3 minutos.  
> [!CONSEJO]  
> Esta parte del código está definida en la función "giroscompleta"  
> [!NOTA]  
> Este cambio sencillo nos ahorra alrededor de 30 segundos por vuelta, dándonos suficiente tiempo para hacer todo el desafío.  

## Estacionamiento desafío de obstáculos  
Como sabemos que el robot siempre estará en un carril exacto, podemos asumir que nunca detectará un pilar con el sensor ultrasónico, por eso la estrategia de estacionamiento sólo incluye el sensor ultrasónico y el Giroscopio.  
```cpp  
if(giro==12&&d<120){  
  delay(800);  
  pro.write(derecha);  
  girarder90();  
  pro.write(rec);  
  delay(3000);  
  digitalWrite(2,0);  
  delay(10000000);  
}  
```



> [!IMPORTANT]
> El codigo del segundo reto se basa en los mismos principios que el codigo utilizado hasta este momento,





# Diseño mecánico
"Pompo" es un robot autónomo diseñado con piezas de lego, con la finalidad de conseguir la mayor presición y estabilidad posible durante las rondas de competencia. Dichas piezas fueron extraídas de un kit lego spike prime código 45678 y spike prime expansion set código 45681. 
El fundamento que llevó a utilizar piezas de lego para el cuerpo de pompo se basa en la conocida eficiencia de los robots construidos de dicha manera, tomando en cuenta los resultados positivos y la facilidad que permiten a la hora de la construcción. 
Además, en el apartado "v-photos" se muestran fotos del diseño de Pompo, donde se pueden ver y analizar eficientemente todos los componentes, piezas y estructuras.
A continuación el diseño 3D de las diversas bases de lego que se usan en la estructura (en el apartado "models" se ve el archivo original del diseño): 

![Image](https://github.com/user-attachments/assets/5b7af0b6-441f-4880-8d1f-e71637f6b006)

![Image](https://github.com/user-attachments/assets/a4c70eec-a4b5-4d26-86e3-5d2190d3b326)

![Image](https://github.com/user-attachments/assets/dd3a7d52-695a-4912-9071-1e9b083b1505)



## Componentes electrónicos 
A pesar de que la construcción del robot fue hecha con piezas de lego, para todo el apartado electrónico el equipo se decidió por utilizar piezas externas con las que ya se han familiarizado. Entre estas se encuentran los siguientes sensores y actuadores:


Arduino Mega 2560: Es una placa microcontroladora basada en el ATmega2560. Tiene 54 pines de entrada/salida digital y 16 entradas analógicas, un oscilador de cristal de 16 MHz, una conexión USB, una toma de alimentación, una cabecera ICSP y un botón reset. El arduino es la placa que contiene el código para el funcionamiento de pompo, encargándose de analizar toda la información obtenida por los sensores para así lograr cumplir con el reto. 

![mega 2560](https://github.com/user-attachments/assets/edc71e77-3581-48eb-af96-6dfae65660ac)


Puente-H: Es un tipo de controlador que permite cambiar la polaridad de un motor de corriente continua, hacia delante y hacia atrás, además de ser la fuente de energía de diversos sensores. El modelo de puente H utilizado es el L298N, que nos permite cambiar la velocidad de los motores en función de la tensión enviada por el Arduino.

![puente H pequeño](https://github.com/RoboticaLLR/RedMachine/assets/146040533/264757f2-118f-42c9-9dd8-2a3c91455834)

Sensor de ultrasonido: Es un sensor que utiliza sonidos ultrasónicos para detectar el tiempo de rebote del sonido de un lado a otro. Utilizando el Arduino Mega 2560 se determina la distancia en base al tiempo que tarda la onda en volver, teniendo así este sensor la función de determinar cuando hay una pared cerca para así realizar el giro correspondiente.
El modelo utilizado de este sensor es el HC-sr04.

![HC-sr04](https://github.com/user-attachments/assets/a59b0102-8994-4ac4-aa06-3d6553ae1a2d)

Giroscopio: Es un sensor que mide la orientación del robot en grados. Se utiliza para poder realizar giros precisos, principalmente con la función de los giros para cambio de sección (giros de 90°), y mantener el robot con un movimiento en línea recta. 
El modelo utilizado de este sensor es 

![BNO055](https://github.com/user-attachments/assets/02c487ce-d624-411f-9db3-a2a3ef82a514)

Pixy 2.1: Es una cámara que tiene guardados valores que corresponden a los colores rgb de las señales de tráfico. Para detectar, la cámara busca esos valores en los píxeles de la imagen y, cuando se detecta un número exacto de pixeles de alguno de los colores anexados, pixy envía los datos al arduino, el cual se encarga luego de realizar los movimientos precisos para evitar los semáforos. 

![pixy2 1 2](https://github.com/user-attachments/assets/6397d5c9-d6fe-4c80-a7b9-d097bee0ba3e)


Servo motor de Rev Robotics: Es un motor eléctrico con sensor de retroalimentación de posición integrado, que permite realizar movimientos angulares perfectos, utilizando una señal que va de 0V a 5V, donde cada valor que pueda tener el voltaje representa un ángulo exacto, cumpliendo con excelencia la función de realizar los giros.

![servo pequeño](https://github.com/RoboticaLLR/RedMachine/assets/146040533/57aaa91d-b5e5-4360-aef2-06025d15f8b0)

Motor lego ev3: Dispositivo que convierte la energía eléctrica en movimiento mecánico, permitiendo en este caso mover una caja de cambios y movilizar las ruedas. La velocidad y el par que tiene vienen determinados por la tensión enviada a través del puente en H, siendo moderados por el Arduino.

![Image](https://github.com/user-attachments/assets/05c10969-e9a6-404b-a141-5e44218d54df)

Raspberry pi 5: Es la última versión de las computadoras de placa única desarrolladas por la Fundación Raspberry Pi, lanzada en 2023. Esta versión incluye un procesador Broadcom BCM2712 de cuatro núcleos Arm Cortex-A76 a 2,4 GHz, lo que la hace entre dos y tres veces más rápida que la generación anterior. Viene en versiones de 4 GB y 8 GB de memoria RAM LPDDR4X, incorpora una GPU mejorada compatible con OpenGL ES 3.1 y Vulkan 1.2, y permite conectar dos monitores 4K a 60 Hz al mismo tiempo. Además, ofrece conectividad avanzada con Wi-Fi 5, Bluetooth 5.0, Ethernet Gigabit, dos puertos USB 3.0, dos USB 2.0, dos micro HDMI, ranura microSD de alta velocidad, conectores MIPI para cámaras y pantallas, y un puerto PCIe para discos SSD u otros periféricos rápidos (usando un adaptador). También cuenta con un botón de encendido, reloj en tiempo real, soporte para ventilador y mejoras en la gestión de energía. Gracias a estas características, la Raspberry Pi 5 es ideal tanto para proyectos de electrónica y robótica como para usarse como mini PC, servidor, centro multimedia o incluso para tareas más exigentes como inteligencia artificial y procesamiento de imágenes, representando un gran avance en potencia y versatilidad dentro del mundo de las computadoras compactas y económicas.

![Image](https://github.com/user-attachments/assets/33d23ad4-043a-4c6b-8bab-c31a648c3e4a)

Sensor LiDAR: Un sensor LiDAR (Light Detection and Ranging) es un dispositivo de teledetección que utiliza pulsos de luz láser para medir distancias con gran precisión y crear mapas tridimensionales del entorno. Su funcionamiento se basa en emitir miles de pulsos de láser por segundo hacia los objetos; estos pulsos rebotan y regresan al sensor, que mide el tiempo que tarda cada pulso en ir y volver. Como la velocidad de la luz es conocida, este tiempo de vuelo permite calcular la distancia exacta entre el sensor y los objetos o superficies. Los datos recolectados se procesan para formar una nube de puntos, que es una representación 3D detallada del área escaneada.

![Image](https://github.com/user-attachments/assets/234ebb64-bf87-4ec4-82ca-5e8cac3d7af3)

En este momento la raspberry y el sensor LiDAR estan incluidos en la estructura del robot, sin embargo no se utilizan para la realización del reto.

El Arduino está alimentado por una batería de 9v, y enciende mediante un interruptor. Se encarga de alimentar y dar las respectivas señales al servomotor, para que sea capaz de realizar los cruces de forma efectiva con facilidad al giroscopio, además de dar y recibir señales del resto de sensores. 

Por último, el puente H está conectado y alimentado por dos baterías de 3,7v y se enciende con el mismo interruptor que enciende el Arduino.
El puente H recibe señales del Arduino que llevan a mover el motor en diferentes direcciones y velocidades. También se encarga de alimentar los sensores ultrasónicos.
  

# Diseño del software

1. Análisis de imágenes
-  [Procesamiento de imágenes](https://github.com/Samu4035/REDMACHINE-2025/blob/main/src/software.md#Procesamiento-de-imágenes)
-  [Detección de color](https://github.com/Samu4035/REDMACHINE-2025/blob/main/src/software.md#Detección-de-color)
-  [Programación](https://github.com/Samu4035/REDMACHINE-2025/blob/main/src/software.md#Programación)



# Videos del funcionamiento de pompo
 - [FUTUROS INGENIEROS-Reto 1](https://youtu.be/I5WXGXlZpG4?si=D2IsjQdoafDccQmA)

[![Image](https://github.com/user-attachments/assets/3a998c08-fef1-4247-a1c7-fdddfd4fdfc8)](https://youtu.be/I5WXGXlZpG4?si=D2IsjQdoafDccQmA)
 

- [FUTUROS INGENIEROS-Reto 2](https://youtu.be/XvPb05R_A2o?si=kEyuvRi_PKU7EDct)

[![Image](https://github.com/user-attachments/assets/7d8d684a-25f8-4bad-a824-62b761711ac8)](https://youtu.be/XvPb05R_A2o?si=kEyuvRi_PKU7EDct)


# Índice mecánico
Para más información sobre la mecánica, se ha creado un documento en el que puedes consultar las especificaciones de las piezas y mecanismos del robot.

- [Motores](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Análisis-del-funcionamiento-de-los-motores)
- [Sensores](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Sensores)
- [Camera](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Cámara)
- [Placas controladora](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Placas-controladoras)
- [Alimentación del robot](https://github.com/Samu4035/REDMACHINE-2025/blob/main/schemes/Hardware.md#Alimentación-del-robot)



# Historia y cronología del equipo

1. Temporada 2023
- [Julio 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Julio-2023)
- [Agosto 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Agosto-2023)
- [Septiembre 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Septiembre-2023)
- [Octubre 2023](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Octubre-2023)
2. Temporada 2024 
- [Febrero 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Febrero-2024)
- [Marzo 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Marzo-2024)
- [Abril 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Abril-2024)
- [Mayo 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Mayo-2024)
- [Junio 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Junio-2024)
- [Octubre 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Octubre-2024)
- [Noviembre 2024](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Noviembre-2024)
3. Temporada 2025
- [Febrero 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Febrero-2025)
- [Marzo 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Marzo-2025)
- [Abril 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Abril-2025)
- [Mayo 2025](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#Mayo-2025)
4. Julian, Luka y Pompo
- [JULIAN 1.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-1.0)
- [JULIAN 2.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-2.0)
- [JULIAN 3.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-3.0)
- [JULIAN 4.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-4.0)
- [JULIAN 5.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#JULIAN-5.0)
- [LUKA 1.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#LUKA-1.0)

- [LUKA 2.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md)

- [LUKA 3.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#LUKA-3.0)

- [POMPO 1.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#POMPO-1.0)

- [POMPO 2.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#POMPO-2.0)

- [POMPO 3.0](https://github.com/Samu4035/REDMACHINE-2025/blob/main/t-photos/Historia.md#POMPO-3.0)





